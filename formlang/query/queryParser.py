# Generated from query.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\33")
        buf.write("{\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\4\17\t\17\3\2\7\2 \n\2\f\2\16\2#\13\2\3\2\3\2\3\3")
        buf.write("\3\3\3\3\3\3\5\3+\n\3\3\3\3\3\3\4\3\4\3\4\3\5\3\5\3\5")
        buf.write("\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\b\3\b\3")
        buf.write("\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\5\bK\n\b\3\t\3\t\3")
        buf.write("\t\3\t\5\tQ\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3")
        buf.write("\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13c\n\13\3\f\3\f\3")
        buf.write("\f\5\fh\n\f\3\r\6\rk\n\r\r\r\16\rl\3\16\3\16\5\16q\n\16")
        buf.write("\3\17\3\17\3\17\3\17\3\17\3\17\5\17y\n\17\3\17\2\2\20")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\2\2\2z\2!\3\2\2\2")
        buf.write("\4*\3\2\2\2\6.\3\2\2\2\b\61\3\2\2\2\n\64\3\2\2\2\f8\3")
        buf.write("\2\2\2\16J\3\2\2\2\20P\3\2\2\2\22R\3\2\2\2\24b\3\2\2\2")
        buf.write("\26d\3\2\2\2\30j\3\2\2\2\32n\3\2\2\2\34x\3\2\2\2\36 \5")
        buf.write("\4\3\2\37\36\3\2\2\2 #\3\2\2\2!\37\3\2\2\2!\"\3\2\2\2")
        buf.write("\"$\3\2\2\2#!\3\2\2\2$%\7\2\2\3%\3\3\2\2\2&+\5\6\4\2\'")
        buf.write("+\5\b\5\2(+\5\n\6\2)+\5\f\7\2*&\3\2\2\2*\'\3\2\2\2*(\3")
        buf.write("\2\2\2*)\3\2\2\2+,\3\2\2\2,-\7\7\2\2-\5\3\2\2\2./\7\23")
        buf.write("\2\2/\60\7\32\2\2\60\7\3\2\2\2\61\62\7\22\2\2\62\63\7")
        buf.write("\24\2\2\63\t\3\2\2\2\64\65\7\31\2\2\65\66\7\13\2\2\66")
        buf.write("\67\5\26\f\2\67\13\3\2\2\289\7\25\2\29:\5\16\b\2:;\7\20")
        buf.write("\2\2;<\7\32\2\2<=\7\21\2\2=>\5\22\n\2>\r\3\2\2\2?K\5\20")
        buf.write("\t\2@A\7\16\2\2AB\7\4\2\2BC\5\20\t\2CD\7\5\2\2DK\3\2\2")
        buf.write("\2EF\7\17\2\2FG\7\4\2\2GH\5\20\t\2HI\7\5\2\2IK\3\2\2\2")
        buf.write("J?\3\2\2\2J@\3\2\2\2JE\3\2\2\2K\17\3\2\2\2LQ\7\27\2\2")
        buf.write("MN\7\27\2\2NO\7\6\2\2OQ\7\27\2\2PL\3\2\2\2PM\3\2\2\2Q")
        buf.write("\21\3\2\2\2RS\7\26\2\2ST\7\4\2\2TU\5\24\13\2UV\7\6\2\2")
        buf.write("VW\5\24\13\2WX\7\6\2\2XY\5\26\f\2YZ\7\5\2\2Z\23\3\2\2")
        buf.write("\2[c\7\27\2\2\\c\7\f\2\2]^\7\27\2\2^_\7\t\2\2_`\7\r\2")
        buf.write("\2`a\7\13\2\2ac\7\30\2\2b[\3\2\2\2b\\\3\2\2\2b]\3\2\2")
        buf.write("\2c\25\3\2\2\2dg\5\30\r\2ef\7\b\2\2fh\5\26\f\2ge\3\2\2")
        buf.write("\2gh\3\2\2\2h\27\3\2\2\2ik\5\32\16\2ji\3\2\2\2kl\3\2\2")
        buf.write("\2lj\3\2\2\2lm\3\2\2\2m\31\3\2\2\2np\5\34\17\2oq\7\n\2")
        buf.write("\2po\3\2\2\2pq\3\2\2\2q\33\3\2\2\2ry\7\31\2\2sy\7\27\2")
        buf.write("\2tu\7\4\2\2uv\5\26\f\2vw\7\5\2\2wy\3\2\2\2xr\3\2\2\2")
        buf.write("xs\3\2\2\2xt\3\2\2\2y\35\3\2\2\2\13!*JPbglpx")
        return buf.getvalue()


class queryParser ( Parser ):

    grammarFileName = "query.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "'('", "')'", "','", "';'", 
                     "'|'", "'.'", "'*'", "'='", "'_'", "'id'", "'count'", 
                     "'exists'", "'from'", "'where'", "'list'", "'connect'", 
                     "'graphs'", "'select'", "'path'" ]

    symbolicNames = [ "<INVALID>", "WS", "LBR", "RBR", "COMMA", "SEMICOLON", 
                      "PIPE", "DOT", "STAR", "EQ", "UNDERSCORE", "KW_ID", 
                      "KW_COUNT", "KW_EXISTS", "KW_FROM", "KW_WHERE", "KW_LIST", 
                      "KW_CONNECT", "KW_GRAPHS", "KW_SELECT", "KW_PATH", 
                      "IDENT", "INT", "NONTERMINAL", "STRING", "ERR_CHAR" ]

    RULE_script = 0
    RULE_statement = 1
    RULE_connect_statement = 2
    RULE_list_graphs_statement = 3
    RULE_rule_statement = 4
    RULE_select_statement = 5
    RULE_objexpr = 6
    RULE_vsinfo = 7
    RULE_whereexpr = 8
    RULE_vexpr = 9
    RULE_pattern = 10
    RULE_seq = 11
    RULE_star = 12
    RULE_unit = 13

    ruleNames =  [ "script", "statement", "connect_statement", "list_graphs_statement", 
                   "rule_statement", "select_statement", "objexpr", "vsinfo", 
                   "whereexpr", "vexpr", "pattern", "seq", "star", "unit" ]

    EOF = Token.EOF
    WS=1
    LBR=2
    RBR=3
    COMMA=4
    SEMICOLON=5
    PIPE=6
    DOT=7
    STAR=8
    EQ=9
    UNDERSCORE=10
    KW_ID=11
    KW_COUNT=12
    KW_EXISTS=13
    KW_FROM=14
    KW_WHERE=15
    KW_LIST=16
    KW_CONNECT=17
    KW_GRAPHS=18
    KW_SELECT=19
    KW_PATH=20
    IDENT=21
    INT=22
    NONTERMINAL=23
    STRING=24
    ERR_CHAR=25

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ScriptContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(queryParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(queryParser.StatementContext)
            else:
                return self.getTypedRuleContext(queryParser.StatementContext,i)


        def getRuleIndex(self):
            return queryParser.RULE_script

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript" ):
                listener.enterScript(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript" ):
                listener.exitScript(self)




    def script(self):

        localctx = queryParser.ScriptContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_script)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 31
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << queryParser.KW_LIST) | (1 << queryParser.KW_CONNECT) | (1 << queryParser.KW_SELECT) | (1 << queryParser.NONTERMINAL))) != 0):
                self.state = 28
                self.statement()
                self.state = 33
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 34
            self.match(queryParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEMICOLON(self):
            return self.getToken(queryParser.SEMICOLON, 0)

        def connect_statement(self):
            return self.getTypedRuleContext(queryParser.Connect_statementContext,0)


        def list_graphs_statement(self):
            return self.getTypedRuleContext(queryParser.List_graphs_statementContext,0)


        def rule_statement(self):
            return self.getTypedRuleContext(queryParser.Rule_statementContext,0)


        def select_statement(self):
            return self.getTypedRuleContext(queryParser.Select_statementContext,0)


        def getRuleIndex(self):
            return queryParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = queryParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 40
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [queryParser.KW_CONNECT]:
                self.state = 36
                self.connect_statement()
                pass
            elif token in [queryParser.KW_LIST]:
                self.state = 37
                self.list_graphs_statement()
                pass
            elif token in [queryParser.NONTERMINAL]:
                self.state = 38
                self.rule_statement()
                pass
            elif token in [queryParser.KW_SELECT]:
                self.state = 39
                self.select_statement()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 42
            self.match(queryParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Connect_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_CONNECT(self):
            return self.getToken(queryParser.KW_CONNECT, 0)

        def STRING(self):
            return self.getToken(queryParser.STRING, 0)

        def getRuleIndex(self):
            return queryParser.RULE_connect_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConnect_statement" ):
                listener.enterConnect_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConnect_statement" ):
                listener.exitConnect_statement(self)




    def connect_statement(self):

        localctx = queryParser.Connect_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_connect_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 44
            self.match(queryParser.KW_CONNECT)
            self.state = 45
            self.match(queryParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_graphs_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_LIST(self):
            return self.getToken(queryParser.KW_LIST, 0)

        def KW_GRAPHS(self):
            return self.getToken(queryParser.KW_GRAPHS, 0)

        def getRuleIndex(self):
            return queryParser.RULE_list_graphs_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_graphs_statement" ):
                listener.enterList_graphs_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_graphs_statement" ):
                listener.exitList_graphs_statement(self)




    def list_graphs_statement(self):

        localctx = queryParser.List_graphs_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_list_graphs_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47
            self.match(queryParser.KW_LIST)
            self.state = 48
            self.match(queryParser.KW_GRAPHS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rule_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NONTERMINAL(self):
            return self.getToken(queryParser.NONTERMINAL, 0)

        def EQ(self):
            return self.getToken(queryParser.EQ, 0)

        def pattern(self):
            return self.getTypedRuleContext(queryParser.PatternContext,0)


        def getRuleIndex(self):
            return queryParser.RULE_rule_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule_statement" ):
                listener.enterRule_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule_statement" ):
                listener.exitRule_statement(self)




    def rule_statement(self):

        localctx = queryParser.Rule_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_rule_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 50
            self.match(queryParser.NONTERMINAL)
            self.state = 51
            self.match(queryParser.EQ)
            self.state = 52
            self.pattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_SELECT(self):
            return self.getToken(queryParser.KW_SELECT, 0)

        def objexpr(self):
            return self.getTypedRuleContext(queryParser.ObjexprContext,0)


        def KW_FROM(self):
            return self.getToken(queryParser.KW_FROM, 0)

        def STRING(self):
            return self.getToken(queryParser.STRING, 0)

        def KW_WHERE(self):
            return self.getToken(queryParser.KW_WHERE, 0)

        def whereexpr(self):
            return self.getTypedRuleContext(queryParser.WhereexprContext,0)


        def getRuleIndex(self):
            return queryParser.RULE_select_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_statement" ):
                listener.enterSelect_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_statement" ):
                listener.exitSelect_statement(self)




    def select_statement(self):

        localctx = queryParser.Select_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_select_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(queryParser.KW_SELECT)
            self.state = 55
            self.objexpr()
            self.state = 56
            self.match(queryParser.KW_FROM)
            self.state = 57
            self.match(queryParser.STRING)
            self.state = 58
            self.match(queryParser.KW_WHERE)
            self.state = 59
            self.whereexpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjexprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vsinfo(self):
            return self.getTypedRuleContext(queryParser.VsinfoContext,0)


        def KW_COUNT(self):
            return self.getToken(queryParser.KW_COUNT, 0)

        def LBR(self):
            return self.getToken(queryParser.LBR, 0)

        def RBR(self):
            return self.getToken(queryParser.RBR, 0)

        def KW_EXISTS(self):
            return self.getToken(queryParser.KW_EXISTS, 0)

        def getRuleIndex(self):
            return queryParser.RULE_objexpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjexpr" ):
                listener.enterObjexpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjexpr" ):
                listener.exitObjexpr(self)




    def objexpr(self):

        localctx = queryParser.ObjexprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_objexpr)
        try:
            self.state = 72
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [queryParser.IDENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 61
                self.vsinfo()
                pass
            elif token in [queryParser.KW_COUNT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 62
                self.match(queryParser.KW_COUNT)
                self.state = 63
                self.match(queryParser.LBR)
                self.state = 64
                self.vsinfo()
                self.state = 65
                self.match(queryParser.RBR)
                pass
            elif token in [queryParser.KW_EXISTS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 67
                self.match(queryParser.KW_EXISTS)
                self.state = 68
                self.match(queryParser.LBR)
                self.state = 69
                self.vsinfo()
                self.state = 70
                self.match(queryParser.RBR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VsinfoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self, i:int=None):
            if i is None:
                return self.getTokens(queryParser.IDENT)
            else:
                return self.getToken(queryParser.IDENT, i)

        def COMMA(self):
            return self.getToken(queryParser.COMMA, 0)

        def getRuleIndex(self):
            return queryParser.RULE_vsinfo

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVsinfo" ):
                listener.enterVsinfo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVsinfo" ):
                listener.exitVsinfo(self)




    def vsinfo(self):

        localctx = queryParser.VsinfoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_vsinfo)
        try:
            self.state = 78
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 74
                self.match(queryParser.IDENT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 75
                self.match(queryParser.IDENT)
                self.state = 76
                self.match(queryParser.COMMA)
                self.state = 77
                self.match(queryParser.IDENT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereexprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KW_PATH(self):
            return self.getToken(queryParser.KW_PATH, 0)

        def LBR(self):
            return self.getToken(queryParser.LBR, 0)

        def vexpr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(queryParser.VexprContext)
            else:
                return self.getTypedRuleContext(queryParser.VexprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(queryParser.COMMA)
            else:
                return self.getToken(queryParser.COMMA, i)

        def pattern(self):
            return self.getTypedRuleContext(queryParser.PatternContext,0)


        def RBR(self):
            return self.getToken(queryParser.RBR, 0)

        def getRuleIndex(self):
            return queryParser.RULE_whereexpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhereexpr" ):
                listener.enterWhereexpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhereexpr" ):
                listener.exitWhereexpr(self)




    def whereexpr(self):

        localctx = queryParser.WhereexprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_whereexpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.match(queryParser.KW_PATH)
            self.state = 81
            self.match(queryParser.LBR)
            self.state = 82
            self.vexpr()
            self.state = 83
            self.match(queryParser.COMMA)
            self.state = 84
            self.vexpr()
            self.state = 85
            self.match(queryParser.COMMA)
            self.state = 86
            self.pattern()
            self.state = 87
            self.match(queryParser.RBR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VexprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(queryParser.IDENT, 0)

        def UNDERSCORE(self):
            return self.getToken(queryParser.UNDERSCORE, 0)

        def DOT(self):
            return self.getToken(queryParser.DOT, 0)

        def KW_ID(self):
            return self.getToken(queryParser.KW_ID, 0)

        def EQ(self):
            return self.getToken(queryParser.EQ, 0)

        def INT(self):
            return self.getToken(queryParser.INT, 0)

        def getRuleIndex(self):
            return queryParser.RULE_vexpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVexpr" ):
                listener.enterVexpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVexpr" ):
                listener.exitVexpr(self)




    def vexpr(self):

        localctx = queryParser.VexprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_vexpr)
        try:
            self.state = 96
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 89
                self.match(queryParser.IDENT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 90
                self.match(queryParser.UNDERSCORE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 91
                self.match(queryParser.IDENT)
                self.state = 92
                self.match(queryParser.DOT)
                self.state = 93
                self.match(queryParser.KW_ID)
                self.state = 94
                self.match(queryParser.EQ)
                self.state = 95
                self.match(queryParser.INT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def seq(self):
            return self.getTypedRuleContext(queryParser.SeqContext,0)


        def PIPE(self):
            return self.getToken(queryParser.PIPE, 0)

        def pattern(self):
            return self.getTypedRuleContext(queryParser.PatternContext,0)


        def getRuleIndex(self):
            return queryParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)




    def pattern(self):

        localctx = queryParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.seq()
            self.state = 101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==queryParser.PIPE:
                self.state = 99
                self.match(queryParser.PIPE)
                self.state = 100
                self.pattern()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def star(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(queryParser.StarContext)
            else:
                return self.getTypedRuleContext(queryParser.StarContext,i)


        def getRuleIndex(self):
            return queryParser.RULE_seq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSeq" ):
                listener.enterSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSeq" ):
                listener.exitSeq(self)




    def seq(self):

        localctx = queryParser.SeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_seq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 103
                self.star()
                self.state = 106 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << queryParser.LBR) | (1 << queryParser.IDENT) | (1 << queryParser.NONTERMINAL))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unit(self):
            return self.getTypedRuleContext(queryParser.UnitContext,0)


        def STAR(self):
            return self.getToken(queryParser.STAR, 0)

        def getRuleIndex(self):
            return queryParser.RULE_star

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStar" ):
                listener.enterStar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStar" ):
                listener.exitStar(self)




    def star(self):

        localctx = queryParser.StarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_star)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 108
            self.unit()
            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==queryParser.STAR:
                self.state = 109
                self.match(queryParser.STAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NONTERMINAL(self):
            return self.getToken(queryParser.NONTERMINAL, 0)

        def IDENT(self):
            return self.getToken(queryParser.IDENT, 0)

        def LBR(self):
            return self.getToken(queryParser.LBR, 0)

        def pattern(self):
            return self.getTypedRuleContext(queryParser.PatternContext,0)


        def RBR(self):
            return self.getToken(queryParser.RBR, 0)

        def getRuleIndex(self):
            return queryParser.RULE_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit" ):
                listener.enterUnit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit" ):
                listener.exitUnit(self)




    def unit(self):

        localctx = queryParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_unit)
        try:
            self.state = 118
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [queryParser.NONTERMINAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 112
                self.match(queryParser.NONTERMINAL)
                pass
            elif token in [queryParser.IDENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 113
                self.match(queryParser.IDENT)
                pass
            elif token in [queryParser.LBR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 114
                self.match(queryParser.LBR)
                self.state = 115
                self.pattern()
                self.state = 116
                self.match(queryParser.RBR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





